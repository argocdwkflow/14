#!/usr/bin/env bash
# Script minimal pour vérifier l'accès SSH à une liste d'hôtes
# Usage: ./check_ssh_status_simple.sh -f hosts.txt [-t 8]

set -u

HOSTFILE=""
TIMEOUT_SECS=10

while getopts "f:t:h" opt; do
  case "$opt" in
    f) HOSTFILE="$OPTARG";;
    t) TIMEOUT_SECS="$OPTARG";;
    h) echo "Usage: $0 -f hosts.txt [-t timeout]"; exit 0;;
    *) exit 1;;
  esac
done

[[ -z "$HOSTFILE" || ! -r "$HOSTFILE" ]] && { echo "ERREUR: fichier hosts invalide."; exit 1; }
command -v timeout >/dev/null 2>&1 || { echo "Le binaire 'timeout' est requis."; exit 1; }

echo
printf "%-30s %-10s %s\n" "HOST" "STATUS" "MESSAGE"
printf "%0.s-" {1..70}; echo

declare -A CNT=([OK]=0 [TIMEOUT]=0 [FAILED]=0)

check_host() {
  local host="$1"
  # Exécution protégée par timeout
  out="$(timeout "$TIMEOUT_SECS" ssh "$host" 'echo SSH_OK' 2>&1)"
  rc=$?
  if [[ $rc -eq 0 && "$out" == *"SSH_OK"* ]]; then
    status="OK"; msg="Connexion OK"
  elif [[ $rc -eq 124 ]]; then
    status="TIMEOUT"; msg="Aucune réponse (timeout)"
  else
    status="FAILED"; msg="$(echo "$out" | tr '\n' ' ' | cut -c1-100)"
  fi
  (( CNT[$status]++ ))
  printf "%-30s %-10s %s\n" "$host" "$status" "$msg"
}

while IFS= read -r host || [[ -n "$host" ]]; do
  host="$(echo "$host" | sed 's/^[ \t]*//;s/[ \t]*$//')"
  [[ -z "$host" || "$host" =~ ^# ]] && continue
  check_host "$host" &
  # petite pause pour ne pas saturer le réseau
  sleep 0.1
done < "$HOSTFILE"

wait
printf "%0.s-" {1..70}; echo
echo "Résumé :"
for k in OK TIMEOUT FAILED; do
  printf "  %-10s : %d\n" "$k" "${CNT[$k]}"
done